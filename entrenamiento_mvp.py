# -*- coding: utf-8 -*-
"""Entrenamiento_MVP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_FyPKCFfdZ9HRGUqytYJXlyQcCvvpraN
"""

import pandas as pd
import numpy as np


#train_test_split: separa datos en entrenamiento y test
#ColumnTransformer: aplica transformaciones distintas a columnas distintas
#OneHotEncoder: convierte categorías (aerolíneas) en números
#Pipeline: encadena pasos (preprocesado + modelo)
#LogisticRegression: modelo base del MVP
#Métricas para evaluar el modelo

from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, roc_auc_score

import joblib
#joblib permite guardar y cargar modelos entrenados .pkl

df = pd.read_csv("dataset_vuelos_clima_final.csv")

print(df.shape)
df.head()

#columnas que queremos obligatorias`

required_cols = [
    "hour",
    "distance",
    "marketing_airline_network",
    "temp_mean",
    "precipitation",
    "wind_speed",
    "delayed"
]

#limpio nulos

df = df.dropna(subset=required_cols)

#elimino horas y vuelos que no valen

df = df[df["hour"].between(0, 23)]
df = df[df["distance"] > 0]

#elegimos columnas para input.

FEATURES = [
    "hour",
    "distance",
    "marketing_airline_network",
    "temp_mean",
    "precipitation",
    "wind_speed"
]

TARGET = "delayed"

#separamos x= lo que sabemos antes del vuelo de y = lo que queremos predecir

X = df[FEATURES]
y = df[TARGET]

#lista columnas numericas, distinto a categorías

numeric_features = [
    "hour",
    "distance",
    "temp_mean",
    "precipitation",
    "wind_speed"
]

categorical_features = [
    "marketing_airline_network"
]

#procesamos. pasamos numéricas como están y aplicamos One Hot Encoding para evitar leakage

preprocessor = ColumnTransformer(
    transformers=[
        ("num", "passthrough", numeric_features),
        ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_features)
    ]
)

#logistic regression, class_weight="balanced": corrige desbalance, max_iter=1000: asegura convergencia

model = Pipeline(steps=[
    ("preprocess", preprocessor),
    ("classifier", LogisticRegression(
        max_iter=1000,
        class_weight="balanced"
    ))
])

#80% entrenamiento, 20% test manteniendo proporción retrasos.

X_train, X_test, y_train, y_test = train_test_split(
    X,
    y,
    test_size=0.2,
    random_state=42,
    stratify=y
)

#hacemos que aprenda patrones de delay

model.fit(X_train, y_train)

#predicciçon binaria y probabilidad de retraso. #medimos precisión, recall, f1 y capacidad de ranking ROC AUC

from sklearn.metrics import classification_report, roc_auc_score

y_pred = model.predict(X_test)
y_proba = model.predict_proba(X_test)[:, 1]

print("Classification Report:\n")
print(classification_report(y_test, y_pred))

print("ROC AUC:", roc_auc_score(y_test, y_proba))

#guardamos modelo en pickle, listo para backend.

import joblib

joblib.dump(model, "flight_delay_model.pkl")

#hacemos random forest

from sklearn.ensemble import RandomForestClassifier

#random forest

rf_model = Pipeline(steps=[
    ("preprocess", preprocessor),
    ("classifier", RandomForestClassifier(
        n_estimators=100,
        max_depth=10,
        random_state=42,
        class_weight="balanced"
    ))
])

rf_model.fit(X_train, y_train)

y_pred_rf = rf_model.predict(X_test)
y_proba_rf = rf_model.predict_proba(X_test)[:, 1]

print("RANDOM FOREST - Classification Report:\n")
print(classification_report(y_test, y_pred_rf))

print("RANDOM FOREST - ROC AUC:", roc_auc_score(y_test, y_proba_rf))

#simulamos endpoint


import pandas as pd

def predict_flight_delay(input_json, model):
    """
    Simula el endpoint POST /predict
    """

    #Parsear fecha

    fecha = pd.to_datetime(input_json["fecha_partida"])


    #Construir DataFrame de entrada

    df_input = pd.DataFrame([{
        "hour": fecha.hour,
        "distance": input_json["distancia_km"],
        "marketing_airline_network": input_json["aerolinea"],
        "temp_mean": 20.0,        # valor por defecto (MVP)
        "precipitation": 0.0,     # valor por defecto (MVP)
        "wind_speed": 10.0        # valor por defecto (MVP)
    }])

    #Predicción
    pred = model.predict(df_input)[0]
    proba = model.predict_proba(df_input)[0, 1]

    #Respuesta
    return {
        "prevision": "Retrasado" if pred == 1 else "Puntual",
        "probabilidad": round(float(proba), 2)
    }

#ejemplo de request

input_example = {
    "aerolinea": "AZ",
    "origen": "GIG",
    "destino": "GRU",
    "fecha_partida": "2025-11-10T14:30:00",
    "distancia_km": 350
}

response = predict_flight_delay(input_example, model)
print(response)

import joblib

joblib.dump(model, "MVP_entrenamiento.pkl")

#Distribución clases, historiograma de probabilidades, curva ROC, vareiables importantes


import matplotlib.pyplot as plt

df["delayed"].value_counts().plot(kind="bar")
plt.title("Distribución de vuelos Puntuales vs Retrasados")
plt.xlabel("Clase (0=Puntual, 1=Retrasado)")
plt.ylabel("Número de vuelos")
plt.show()

plt.hist(y_proba, bins=20)
plt.title("Distribución de probabilidad de retraso")
plt.xlabel("Probabilidad de retraso")
plt.ylabel("Número de vuelos")
plt.show()

from sklearn.metrics import roc_curve

fpr, tpr, _ = roc_curve(y_test, y_proba)

plt.plot(fpr, tpr)
plt.plot([0, 1], [0, 1], linestyle="--")
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("Curva ROC - Logistic Regression")
plt.show()

# Obtener nombres reales de las features
numeric_names = numeric_features

categorical_names = (
    model.named_steps["preprocess"]
    .named_transformers_["cat"]
    .get_feature_names_out(categorical_features)
)

feature_names = list(numeric_names) + list(categorical_names)

# Coeficientes del modelo
coefficients = model.named_steps["classifier"].coef_[0]    #Extrae el peso real de cada feature

importance_df = pd.DataFrame({
    "feature": feature_names,
    "importance": coefficients
}).sort_values(by="importance")



# Gráfica
importance_df.plot(
    x="feature",
    y="importance",
    kind="barh",
    figsize=(9, 7),
    legend=False
)

plt.axvline(0, color="black", linestyle="--")
plt.title("Impacto de las variables en la predicción (escaladas)")
plt.xlabel("Peso en el modelo (Logistic Regression)")
plt.ylabel("Variable")
plt.tight_layout()
plt.show()

def predict_flight_delay(input_json, model):
    fecha = pd.to_datetime(input_json["fecha_partida"])

    df_input = pd.DataFrame([{
        "hour": fecha.hour,
        "distance": input_json["distancia_km"],
        "marketing_airline_network": input_json["aerolinea"],
        "temp_mean": 20.0,
        "precipitation": 0.0,
        "wind_speed": 10.0
    }])

    pred = model.predict(df_input)[0]
    proba = model.predict_proba(df_input)[0, 1]

    return {
        "prevision": "Retrasado" if pred == 1 else "Puntual",
        "probabilidad": round(float(proba), 2)
    }

#Llamamos al endpoint varias veces

inputs = [
    {
        "aerolinea": "AZ",
        "fecha_partida": "2025-11-10T08:30:00",
        "distancia_km": 300
    },
    {
        "aerolinea": "F9",
        "fecha_partida": "2025-11-10T19:45:00",
        "distancia_km": 1200
    },
    {
        "aerolinea": "AA",
        "fecha_partida": "2025-11-10T06:15:00",
        "distancia_km": 800
    },
    {
        "aerolinea": "NK",
        "fecha_partida": "2025-11-10T22:10:00",
        "distancia_km": 1500
    }
]

results = []

for i, inp in enumerate(inputs):
    response = predict_flight_delay(inp, model)
    results.append({
        "vuelo": f"Vuelo {i+1}",
        "aerolinea": inp["aerolinea"],
        "probabilidad": response["probabilidad"],
        "prevision": response["prevision"]
    })

df_results = pd.DataFrame(results)
df_results

import matplotlib.pyplot as plt

plt.figure(figsize=(8, 5))

plt.bar(
    df_results["vuelo"],
    df_results["probabilidad"]
)

plt.axhline(0.5, linestyle="--")
plt.title("Simulación del endpoint /predict")
plt.ylabel("Probabilidad de retraso")
plt.xlabel("Solicitud al endpoint")

for i, row in df_results.iterrows():
    plt.text(
        i,
        row["probabilidad"] + 0.02,
        row["prevision"],
        ha="center"
    )

plt.ylim(0, 1)
plt.show()

#Matrices de confusión.

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

cm = confusion_matrix(y_test, y_pred)

disp = ConfusionMatrixDisplay(
    confusion_matrix=cm,
    display_labels=["Puntual", "Retrasado"]
)

disp.plot(cmap="Blues")
plt.title("Matriz de confusión - Logistic Regression")
plt.show()

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt

# Predicciones del Random Forest
y_pred_rf = rf_model.predict(X_test)

# Matriz de confusión
cm_rf = confusion_matrix(y_test, y_pred_rf)

disp_rf = ConfusionMatrixDisplay(
    confusion_matrix=cm_rf,
    display_labels=["Puntual", "Retrasado"]
)

disp_rf.plot(cmap="Greens")
plt.title("Matriz de confusión - Random Forest")
plt.show()

# --- Ajuste de umbral para aumentar precision ---

from sklearn.metrics import classification_report, confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt

# Probabilidades de retraso
y_proba = model.predict_proba(X_test)[:, 1]

# Umbral más estricto
threshold = 0.65
y_pred_precise = (y_proba >= threshold).astype(int)

# Métricas
print(f"Resultados con umbral = {threshold}")
print(classification_report(y_test, y_pred_precise))

# Matriz de confusión
cm_thresh = confusion_matrix(y_test, y_pred_precise)

disp_thresh = ConfusionMatrixDisplay(
    confusion_matrix=cm_thresh,
    display_labels=["Puntual", "Retrasado"]
)

disp_thresh.plot(cmap="Purples")
plt.title(f"Matriz de confusión (umbral = {threshold})")
plt.show()

from sklearn.ensemble import RandomForestClassifier
from sklearn.pipeline import Pipeline
rf_model_tuned = Pipeline(steps=[
    ("preprocess", preprocessor),
    ("classifier", RandomForestClassifier(
        n_estimators=300,
        max_depth=10,
        min_samples_leaf=5,
        random_state=42,
        class_weight="balanced"
    ))
])

rf_model_tuned.fit(X_train, y_train)

from sklearn.metrics import classification_report, roc_auc_score

y_pred_rf_tuned = rf_model_tuned.predict(X_test)
y_proba_rf_tuned = rf_model_tuned.predict_proba(X_test)[:, 1]

print("Random Forest ajustado")
print(classification_report(y_test, y_pred_rf_tuned))
print("ROC AUC:", roc_auc_score(y_test, y_proba_rf_tuned))

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt

cm_rf_tuned = confusion_matrix(y_test, y_pred_rf_tuned)

disp_rf_tuned = ConfusionMatrixDisplay(
    confusion_matrix=cm_rf_tuned,
    display_labels=["Puntual", "Retrasado"]
)

disp_rf_tuned.plot(cmap="Oranges")
plt.title("Matriz de confusión - Random Forest ajustado")
plt.show()