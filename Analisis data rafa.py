# -*- coding: utf-8 -*-
"""Rafaflight.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_MHzc-KVpSGhVcqIrJn9HVOBYN5y4mOC
"""

import kagglehub


path = kagglehub.dataset_download("arvindnagaonkar/flight-delay")

print("Path to dataset files:", path)

import os

os.listdir(path)

import pyarrow.parquet as pq
import os
from pathlib import Path

parquet_file = Path("/kaggle/input/flight-delay/Flight_Delay.parquet")

# Tamaño del archivo
file_size_mb = os.path.getsize(parquet_file) / (1024 * 1024)
print(f"Tamaño del archivo: {file_size_mb:.2f} MB")

# Leer metadata completa
parquet_metadata = pq.ParquetFile(parquet_file)
num_filas = parquet_metadata.metadata.num_rows
num_columnas = parquet_metadata.metadata.num_columns

print(f"Filas: {num_filas}")
print(f"Columnas: {num_columnas}")

import pandas as pd
from pathlib import Path

# Ruta al archivo Parquet
parquet_file = Path("/kaggle/input/flight-delay/Flight_Delay.parquet")

# Cargar una muestra de 100k filas
df_full = pd.read_parquet(parquet_file, engine="pyarrow")  # carga todo
df = df_full.sample(n=100_000, random_state=42)  # toma muestra aleatoria

print("Shape de la muestra:", df.shape)

import pyarrow.parquet as pq
import pandas as pd

parquet_file = "/kaggle/input/flight-delay/Flight_Delay.parquet"
n_sample = 100_000

# Abrir Parquet
table = pq.ParquetFile(parquet_file)

sample_rows = []
rows_collected = 0

for batch in table.iter_batches(batch_size=50_000):
    df_batch = batch.to_pandas()  # convierte a Pandas conservando columnas

    remaining = n_sample - rows_collected
    if len(df_batch) >= remaining:
        sample_rows.append(df_batch.sample(n=remaining, random_state=42))
        break
    else:
        sample_rows.append(df_batch)
        rows_collected += len(df_batch)

# Concatenar en un único DataFrame
df_sample = pd.concat(sample_rows, ignore_index=True)

# Columnas están bien
print("Shape de la muestra:", df_sample.shape)
print("Columnas:", df_sample.columns.tolist())

# Ver los nombres de columna reales
print(df_sample.columns.tolist())

# Crear variable temporal 'hour' a partir de la hora programada
df_sample["hour"] = df_sample["crsdeptime"] // 100  # solo la hora

# Variable objetivo 'delayed': 1 si el retraso en salida >= 15 min
df_sample["delayed"] = (df_sample["depdelay"] >= 15).astype(int)

# Probabilidad de delay en la muestra
delay_rate = df_sample["delayed"].mean()
print(f"Delay rate: {delay_rate:.4f}")

# Ver valores únicos de la variable 'delayed'
unique_values = df_sample["delayed"].unique()
print("Valores únicos en 'delayed':", unique_values)

import matplotlib.pyplot as plt

# Agrupar por hora y calcular la probabilidad de retraso
hour_delay = (
    df_sample.groupby("hour")["delayed"]
    .mean()
    .sort_index()
)

# Mostrar la tabla de probabilidades por hora
print(hour_delay)


plt.figure(figsize=(10,4))
hour_delay.plot(kind="line", marker="o")
plt.title("Probability of Flight Delay by Scheduled Departure Hour")
plt.xlabel("Hour of Day")
plt.ylabel("Delay Probability")
plt.grid(True)
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Crear bins de distancia (5 quintiles)
df_sample["distance_bin"] = pd.qcut(df_sample["distance"], q=5)

# Calcular probabilidad de retraso por rango de distancia
distance_delay = (
    df_sample.groupby("distance_bin", observed=True)["delayed"]
    .mean()
)


print(distance_delay)

plt.figure(figsize=(8,4))
distance_delay.plot(kind="bar")
plt.title("Delay Probability by Flight Distance")
plt.ylabel("Delay Probability")
plt.xticks(rotation=45)
plt.grid(axis="y")
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Convertir a datetime
df_sample["flightdate"] = pd.to_datetime(df_sample["flightdate"])

# Crear día de la semana (0 = lunes)
df_sample["day_of_week"] = df_sample["flightdate"].dt.dayofweek

# Calcular probabilidad de retraso por día de la semana
dow_delay = (
    df_sample.groupby("day_of_week")["delayed"]
    .mean()
    .sort_index()
)

# Graficar
plt.figure(figsize=(8,4))
dow_delay.plot(kind="bar")
plt.title("Delay Probability by Day of Week (0=Monday)")
plt.xlabel("Day of Week")
plt.ylabel("Delay Probability")
plt.grid(axis="y")
plt.show()

import matplotlib.pyplot as plt

# Probabilidad de retraso por aerolínea (top 10)
airline_delay = (
    df_sample.groupby("marketing_airline_network")["delayed"]
    .mean()
    .sort_values(ascending=False)
    .head(10)
)

# Mostrar resultados
print(airline_delay)

# Graficar
plt.figure(figsize=(8,4))
airline_delay.plot(kind="bar")
plt.title("Top 10 Airlines by Delay Probability")
plt.ylabel("Delay Probability")
plt.xticks(rotation=45)
plt.grid(axis="y")
plt.show()

# Comprobación de variable objetivo binaria
df_sample["delayed"].value_counts(normalize=True)

hour_delay = (
    df_sample.groupby("hour")["delayed"]
    .mean()
)

hour_std = hour_delay.std()

print(f"Std of delay probability by hour: {hour_std:.4f}")

# Este criterio mide cuánto cambia la probabilidad de retraso a lo largo del día;
# si la variación es alta, significa que la hora del vuelo influye de forma real
# en los retrasos, y el ratio entre datasets nos permite comparar cuál captura
# mejor ese patrón temporal sin necesidad de entrenar ni optimizar modelos.

# Al medir la variación de la probabilidad de retraso según la hora, verificamos
# que la hora del vuelo tiene impacto real, y usando el ratio podemos decidir
# qué dataset conserva mejor esa señal predictiva sin incurrir en mayor coste
# computacional.